type Access {
  """
  Current user may create a new app request on behalf of another user and should be shown the Create App Request button on the reviewer dashboard or main app request list.
  """
  createAppRequestOther: Boolean!

  """
  Current user may create a new app request for themselves and should be shown the Create App Request button.
  """
  createAppRequestSelf: Boolean!

  """
  Current user is permitted to create new periods in the period management UI.
  """
  createPeriod: Boolean!

  """
  Current user is permitted to create new roles in the role management UI.
  """
  createRole: Boolean!

  """The current user, if any."""
  user: AccessUser

  """Current user is permitted to view the app request list."""
  viewAppRequestList: Boolean!

  """Current user is permitted to view the applicant dashboard."""
  viewApplicantDashboard: Boolean!

  """Current user is permitted to view the period management UI."""
  viewPeriodManagement: Boolean!

  """Current user is permitted to view the reviewer dashboard."""
  viewReviewerInterface: Boolean!

  """Current user is permitted to view the role management UI."""
  viewRoleManagement: Boolean!
}

type AccessControl {
  description: String!
  name: String!
}

type AccessControlGroup {
  """
  A list of all possible controls for this controlGroup. Use this to populate the control dropdown when creating a grant.
  """
  controls: [AccessControl!]!

  """
  A longer explanation of the control group for display in the role management interface.
  """
  description: String
  name: String!
  tags: [AccessTagCategory!]!

  """
  A slightly longer version of the control group's name, for display in the role management interface.
  """
  title: String!
}

type AccessGrantTag {
  category: String!
  categoryLabel: String!
  label: String!
  tag: String!
}

type AccessRole {
  actions: RoleActions!

  """
  A description of the grant. This is not used for anything, but can be useful for admins to understand what the grant was trying to do.
  """
  description: String
  grants: [AccessRoleGrant!]!
  groups: [AccessRoleGroup!]!
  id: ID!
  name: String!
  scope: String
}

input AccessRoleFilter {
  groups: [String!]
  ids: [ID!]
  names: [String!]
  scopes: [String!]
}

type AccessRoleGrant {
  actions: AccessRoleGrantActions!

  "\n    If true, this grant allows the action specified by the selected controls. If false, it removes\n    the controls.\n\n    Removing a control only happens within the context of a single role. If another role grants the\n    same control, the action is allowed. This is more of an exception system than a denial\n    system. So you can do something like add the \"view\" control to the \"movie\" control group in one\n    grant, and then in a second grant in the same role, remove it from \"The Princess Bride\". Now you\n    have a role that grants \"view\" on all movies _except_ The Princess Bride. If the user has another role\n    that grants \"view\" on The Princess Bride (or on all movies), they can view it based on that other role.\n  "
  allow: Boolean!

  """The group this control belongs to. e.g. Reviewer - Review Phase"""
  controlGroup: AccessControlGroup!
  controls: [String!]!
  id: ID!
  tags: [AccessGrantTag!]!
}

type AccessRoleGrantActions {
  delete: Boolean!
  update: Boolean!
}

input AccessRoleGrantCreate {
  allow: Boolean!
  controlGroup: String

  """
  A list of controls that are allowed or denied by this grant. Each controlGroup has a list of available controls, available under Query.controlGroups.
  """
  controls: [String!]

  """
  A list of tags to restrict a grant. For instance, if this is added to a grant on PromptAnswer-update, each tag refers to a subset of App Requests.
  """
  tags: [AccessTagInput!]
}

input AccessRoleGrantUpdate {
  allow: Boolean!
  controlGroup: String

  """
  A list of controls that are allowed or denied by this grant. Each controlGroup has a list of available controls, available under Query.controlGroups.
  """
  controls: [String!]

  """
  A list of tags to restrict a grant. For instance, if this is added to a grant on PromptAnswer-update, each tag refers to a subset of App Requests.
  """
  tags: [AccessTagInput!]
}

type AccessRoleGroup {
  """The date the group was added to a role."""
  dateAdded: DateTime!
  dateCreated: DateTime!

  """The name of the group. This should be unique even among all roleIds."""
  groupName: String!
  managers: [AccessRoleGroupManager!]!
  roleId: ID!
}

type AccessRoleGroupManager {
  """The date the group was added to a role."""
  email: String

  """The date the group was added to a role."""
  fullname: String!
}

input AccessRoleInput {
  """
  A description of the role. This is not used for anything, but can be useful for admins to understand what the role is trying to do.
  """
  description: String

  """A list of groups this role is associated with."""
  groups: [String!]!
  name: String!

  """Attach this role to a specific authentication scope, e.g. "parent"."""
  scope: String
}

type AccessRoleValidatedResponse {
  accessRole: AccessRole
  messages: [MutationMessage!]!

  """
  True if the mutation succeeded (e.g. saved data or passed validation), even if there were warnings.
  """
  success: Boolean!
}

type AccessTag {
  label: String!
  value: String!
}

type AccessTagCategory {
  category: String!
  description: String
  label: String!
  listable: Boolean!

  """
  A list of all possible tags for this category. Use this to populate the tag dropdown when creating a grant.
  """
  tags: [AccessTag!]!
}

input AccessTagInput {
  """The category this tag belongs to, e.g. "State"."""
  category: String!

  """The tag value, e.g. "TX"."""
  tag: String!
}

"""A user that has or once had access to the system."""
type AccessUser {
  fullname: String!
  groups: [String!]!
  login: ID!
  otherIdentifiers: [AccessUserIdentifier!]!

  """
  A JSON object containing any information about the user that the implementing application wants to store. Could be useful for constructing personalized UI.
  """
  otherInfo: JsonData
  roles: [AccessRole!]!

  """
  True as long as the lookupUser.byLogins function still returns this user. False otherwise. Likely this user has been deactivated.
  """
  stillValid: Boolean!
}

input AccessUserFilter {
  logins: [ID!]

  """
  One to Many groupings Filter, like a institutional role people may belong to.
  """
  otherGroupingsByLabel: [AccessUserGroupingInput!]

  """Filter by identifiers aside from username, like an Employee ID."""
  otherIdentifiers: [String!]
  otherIdentifiersByLabel: [AccessUserIdentifierInput!]

  """Filter users by associated Application Roles"""
  roles: [String!]
  search: String

  """If true, only return the user that is currently logged in."""
  self: Boolean
}

"""
A label and ID pair for an internal and external user related attributes. For example, [{ label: "institutional-role", ids: ["Staff", "Student"] }, { label: "last-login", ids: ["2025-09-01T10:20:04"] }]
"""
input AccessUserGroupingInput {
  ids: [ID!]!
  label: String!
}

"""
A label and ID pair for an external user unique ID. For example, { label: "Student ID", id: "123456" }
"""
type AccessUserIdentifier {
  """The unique ID for this identifier, e.g. "123456"."""
  id: ID!

  """The label for this identifier, e.g. "Student ID"."""
  label: String!
}

"""
A label and ID pair for an external user unique ID. For example, { label: "Student ID", id: "123456" }
"""
input AccessUserIdentifierInput {
  id: ID!
  label: String!
}

"""
Represents a group of applications all being applied for at the same time. As part of the request, multiple applications will be created and either eliminated as ineligible or submitted for approval.
"""
type AppRequest {
  """Actions the user can take on this app request."""
  actions: AppRequestActions!

  """
  The activity log for this app request. This is a list of actions taken on the app request, such as submission, updating prompts, make an offer, add a note, etc. It will be sorted by the date of the activity in descending order.
  """
  activity(
    """
    Filters to apply to the activity log. This can be used to filter by action type, date range, etc.
    """
    filters: AppRequestActivityFilters
  ): [AppRequestActivity!]!
  applicant: AccessUser!
  applications: [Application!]!

  """
  Date that this request was considered closed and no longer editable. If active or re-opened, will be null. If closed again, will be the second closure date.
  """
  closedAt: DateTime
  createdAt: DateTime!

  """
  All data that has been gathered from the user for this request. It is a Record whose properties are the prompt keys and values are the data gathered by the corresponding prompt dialog.
  """
  data(
    """
    Provide the schemaVersion at the time the UI was built. Will throw an error if the client is too old, so it knows to refresh.
    """
    schemaVersion: String
  ): JsonData!

  """
  The version of the data for this app request. This is incremented every time the data is updated. If you provide it with your update requests, the API will perform an optimistic concurrency check and fail the update if someone else has updated the data in the meantime.
  """
  dataVersion: Int!
  id: ID!

  """
  Indexes associated with the App Request. These are pieces of data extracted from the App Request by individual prompts in the ReqQuest project. They have several uses such as filtering App Requests and enriching list views.
  """
  indexCategories(
    """
    Returns indexes that are flagged to appear in this destination. Also sorts for this destination.
    """
    for: AppRequestIndexDestination
  ): [AppRequestIndexCategory!]!

  """The period this appRequest is associated with."""
  period: Period!

  """
  Retrieve a specific prompt by its ID. This is useful for the UI to get the full prompt data and configuration when trying to edit an individual prompt. We don't want to be downloading all the config data for everything up front.
  """
  prompt(promptId: ID!): RequirementPrompt!
  status: AppRequestStatus!

  """
  The most pertinent status reason for this app request. The logic is complicated and depends on the AppRequest's status.
  """
  statusReason: String
  updatedAt: DateTime!
}

type AppRequestActions {
  """
  User may cancel this app request as the owner. Separate from closing as a reviewer/admin.
  """
  cancel: Boolean!

  """
  User may close this app request as a reviewer/admin. Separate from cancelling as the app request owner.
  """
  close: Boolean!

  """User may make an offer on this app request."""
  offer: Boolean!

  """
  User may reopen this app request, whether as the owner or as a reviewer/admin.
  """
  reopen: Boolean!

  """User may return this app request to the applicant phase."""
  return: Boolean!

  """Whether the user can view this app request as a reviewer."""
  review: Boolean!

  """User may submit this app request either as or on behalf of the owner."""
  submit: Boolean!
}

type AppRequestActivity {
  action: String!

  """The app request this activity is associated with."""
  appRequest: AppRequest!

  """The date and time when the action occurred."""
  createdAt: DateTime!

  """
  A JSON object containing additional data about the activity. This could be filtered but different actions would place different data here so it is not strongly typed.
  """
  data: JsonData

  """
  A detailed description of the activity. This is not meant to be filtered and could contain specific details about the action.
  """
  description: String
  id: ID!

  """
  If this activity was performed by an impersonated user, this will be the user that did the impersonation.
  """
  impersonatedBy: AccessUser

  """The user that performed the activity."""
  user: AccessUser!
}

"""This is used to filter a list of activities."""
input AppRequestActivityFilters {
  """
  Filter activities by action. This is a list of action names that should be matched. There are many potential action names, they are untyped.
  """
  actions: [String!]
  appRequestIds: [ID!]

  """Return activities that happened after this date."""
  happenedAfter: DateTime

  """Return activities that happened before this date."""
  happenedBefore: DateTime

  """
  true -> Return activities that were performed while a user was impersonating another user. false -> Return activities that were not impersonated.
  """
  impersonated: Boolean

  """
  Return activities that were performed while one of the given logins was impersonating another user.
  """
  impersonatedBy: [ID!]

  """
  Return activities that were performed while one of the given logins was being impersonated by someone else.
  """
  impersonatedUsers: [ID!]

  """
  Return activities that were performed by one of the given logins. Also returns activities that were performed while one of the given logins was impersonating someone else.
  """
  users: [ID!]
}

input AppRequestFilter {
  """
  true -> only return appRequests that are closed. false -> only return appRequests that are open. null -> return all appRequests.
  """
  closed: Boolean

  """
  Only return appRequests that were closed after this date. Open appRequests will be filtered out.
  """
  closedAfter: DateTime

  """
  Only return appRequests that were closed before this date. Open appRequests will be filtered out.
  """
  closedBefore: DateTime

  """Only return appRequests that were created after this date."""
  createdAfter: DateTime

  """Only return appRequests that were created before this date."""
  createdBefore: DateTime
  ids: [ID!]

  """Only return appRequests that match one of the given indexes."""
  indexes: [AppRequestIndexFilter!]

  """Only return appRequests that are owned by one the given logins."""
  logins: [ID!]

  """Only return appRequests that are owned by the current user."""
  own: Boolean
  periodIds: [ID!]

  """
  Search for appRequests that match this search term. This will do a prefix search across all fields that are indexed.
  """
  search: String
  status: [AppRequestStatus!]

  """
  Only return appRequests that were submitted after this date. App Requests that have not been submitted will be filtered out.
  """
  submittedAfter: DateTime

  """
  Only return appRequests that were submitted before this date. App Requests that have not been submitted will be filtered out.
  """
  submittedBefore: DateTime

  """Only return appRequests that were updated after this date."""
  updatedAfter: DateTime

  """Only return appRequests that were updated before this date."""
  updatedBefore: DateTime
}

"""
This represents an index category attached to an app request. Its tagStrings property contains the tag values that have been extracted from the app request data.
"""
type AppRequestIndexCategory {
  """
  If this is > 0, the index values should be shown on the main app request list page, sorted by this priority in descending order.
  """
  appRequestListPriority: Float

  """
  If this is > 0, the index values should be shown on the applicant dashboard, sorted by this priority in descending order.
  """
  applicantDashboardPriority: Float
  category: String!
  categoryLabel: String!

  """
  If this is > 0, the index values should be shown on the list filters, sorted by this priority in descending order.
  """
  listFiltersPriority: Float
  listable: Boolean!

  """
  If this is > 0, the index values should be shown on the reviewer dashboard, sorted by this priority in descending order.
  """
  reviewerDashboardPriority: Float
  values: [IndexValue!]!
}

"""This is used to indicate where the index values should be displayed."""
enum AppRequestIndexDestination {
  """
  Show these index values when listing App Requests on the applicant dashboard.
  """
  APPLICANT_DASHBOARD

  """
  Show these index values when listing App Requests in the main list page.
  """
  APP_REQUEST_LIST

  """Allow the user to filter on these index values on the main list page."""
  LIST_FILTERS

  """
  Show these index values when listing App Requests on the reviewer dashboard.
  """
  REVIEWER_DASHBOARD
}

input AppRequestIndexFilter {
  category: String!
  tags: [String!]!
}

"\n    The status of an appRequest. This status is computed based on the \"dbStatus\" recorded in\n    the database and the status of each application.\n  "
enum AppRequestStatus {
  """
  Reviewer has approved an offer and we are waiting for the applicant to accept. This status is unreachable if the period has no ACCEPTANCE requirements.
  """
  ACCEPTANCE

  """
  Applicant has accepted an offer on at least one application and no applications are still pending acceptance.
  """
  ACCEPTED

  """
  Applicant has submitted and any pre-approval requirements have been met. We are waiting for a reviewer to do their part.
  """
  APPROVAL

  """
  Results have been released to the applicant, there is no acceptance phase, and at least one application was found eligible.
  """
  APPROVED

  """
  Applicant cancelled the request before submitting. The applicant may be permitted to uncancel and continue, if the period is still open.
  """
  CANCELLED

  """
  Applicant has not yet submitted but ALL applications have been disqualified. Applicant may continue editing prompts until the App Request is closed.
  """
  DISQUALIFIED

  """
  Applicant has responded to the offer, but did not accept an offer on any application.
  """
  NOT_ACCEPTED

  """
  Results have been released to the applicant, there is no acceptance phase, and all applications were found ineligible.
  """
  NOT_APPROVED

  """
  Applicant has submitted and we are waiting for pre-approval requirements to resolve (these are automations like waiting for data to show up in an external system).
  """
  PREAPPROVAL

  """
  Applicant has been offered, satisfied all acceptance requirements and is ready to accept. This status is unreachable if the period has no ACCEPTANCE requirements.
  """
  READY_TO_ACCEPT

  """
  Applicant has completed all prompts and is ready to submit. At least one application is eligible to proceed.
  """
  READY_TO_SUBMIT

  """
  All applications have been reviewed and any blocking workflow stages have been completed. The application is ready for results to be released to the applicant.
  """
  REVIEW_COMPLETE

  """Applicant has begun the process and has not yet submitted."""
  STARTED

  """
  Applicant withdrew the request after submitting. The request must be re-opened (if eligible) to be edited again.
  """
  WITHDRAWN
}

"""
An application represents the applicant applying to a specific program. Each appRequest has multiple applications - one per program defined in the system. Some applications are mutually exclusive and/or will be eliminated early based on PREQUAL requirements, but they all technically exist in the data model - there is no concept of picking one application over another, just two applications where one dies and the other survives.
"""
type Application {
  actions: ApplicationActions!
  id: ID!

  """
  The phase in which this application became ineligible for benefits. Useful for reporting / filtering. Null if the application is not (yet) ineligible.
  """
  ineligiblePhase: IneligiblePhases

  """The navigation title of the program this application is for."""
  navTitle: String!

  """
  The phase of the application. This is usually a computed field, not stored in the database.
  """
  phase: ApplicationPhase!

  """The program key this application corresponds to."""
  programKey: String!
  requirements: [ApplicationRequirement!]!
  status: ApplicationStatus!

  """
  When one of the application's requirements is failing or throwing a warning, its reason will be copied here for convenience. If there is a warning and then later a failure, the failure reason will win.
  """
  statusReason: String

  """The title of the program this application is for."""
  title: String!

  """
  If the program has workflow, it may be divided into multiple stages of audit, each with their own requirements/prompts. This indicates which stage we are currently evaluating, or null if we are not in the workflow phase. An application with no workflow defined will never be in the workflow phase. Starts at 1.
  """
  workflowStage: PeriodWorkflowStage
}

type ApplicationActions {
  viewAsReviewer: Boolean!
}

"\n    The phase of the application. This is usually a computed field, not stored in the database. The phase\n    is computed based on the status of the appRequest and of the requirements for the program.\n  "
enum ApplicationPhase {
  """
  The application has been reviewed and an offer has been made to the applicant. The applicant must accept the offer.
  """
  ACCEPTANCE

  """
  The applicant has submitted the application and any PREAPPROVAL requirements are passing. The application is under review.
  """
  APPROVAL

  """
  The application has been reviewed. If there was a workflow, it is complete. If there was an acceptance phase, the offer was accepted or rejected.
  """
  COMPLETE

  """
  The applicant has submitted the application, but there are automated prompts that need to be filled in before the application will appear on a reviewer's dashboard.
  """
  PREAPPROVAL

  """
  The appRequest has not finished pre-qual yet. The application doesn't properly exist yet.
  """
  PREQUAL

  """
  The applicant is filling out their portion of prompts and has not yet finished.
  """
  QUALIFICATION

  """
  No application requirements are PENDING. The application is ready for the first workflow stage, but a reviewer must manually advance the phase. This phase will be automatically skipped if there are no workflow stages configured/enabled.
  """
  READY_FOR_WORKFLOW

  """
  An offer has been made to the applicant. The acceptance requirements are no longer pending, the application is ready to be finalized.
  """
  READY_TO_ACCEPT

  """
  The applicant has filled out their portion of the prompts but has not yet submitted for review.
  """
  READY_TO_SUBMIT

  """
  The application has been reviewed and any blocking workflow stages have been completed. The application is ready for results (whether eligible or not) to be released to the applicant. A reviewer must manually advanced the phase, and will do so for the whole appRequest, not one application at a time. So the application will sit in this state until all applications are REVIEW_COMPLETE. If there is no acceptance phase (because there are no acceptance requirements), or if the application is not eligible, the makeOffer prompt will move the phase to WORKFLOW_NONBLOCKING or COMPLETE.
  """
  REVIEW_COMPLETE

  """
  The application review has been completed and now there is a workflow process to audit the review BEFORE marking the application status as eligible or ineligible. It should remain pending until the blocking workflow stages have been completed. Workflow stages that evaluate to INELIGIBLE will also make the application status INELIGIBLE. Prompts from the applicant and review phases are locked.
  """
  WORKFLOW_BLOCKING

  """
  The application has been offered and accepted and now there is a workflow process to audit the review AFTER marking the application status as eligible or ineligible. Requirements from non-blocking workflow states cannot affect the application status, but the application will not proceed to the complete phase until all workflow stages are non-PENDING.
  """
  WORKFLOW_NONBLOCKING
}

"""
The specific instance of a requirement on a particular application. Stores the status of the requirement, e.g. being satisfied or not.
"""
type ApplicationRequirement {
  application: Application!

  """
  The configuration data for this requirement in the app request's period.
  """
  configurationData: JsonData

  """
  An internal description of the requirement. Probably not shown to users.
  """
  description: String!
  id: ID!

  """
  A human and machine readable unique and stable identifier that we can use to add javascript logic to the evaluation of whether a requirement is satisfied. For example: "gi_ch33_must_be_post911"
  """
  key: String!

  """
  A human readable title for the requirement in the navigation. You probably want it to be shorter than the full title. If not provided, the title will be used.
  """
  navTitle: String!
  prompts: [RequirementPrompt!]!

  """
  The smart title for this requirement in the app request's period. For instance, might be "Applicant must have GPA over 3.4" instead of the regular title "Applicant must meet GPA requirement". Will fall back to the regular title for any requirement that does not provide a smart title.
  """
  smartTitle: String!

  """The status of the requirement. This is what will be shown to users."""
  status: RequirementStatus!

  """
  The reason why the requirement is in the status it is in. This will be shown to the applicant.
  """
  statusReason: String

  """
  A human readable title for the requirement. This is what will be shown to users.
  """
  title: String!

  """
  The type of requirement. This determines when the requirement is evaluated and who can see the requirement.
  """
  type: RequirementType!

  """
  The stage of the workflow for this requirement. Null if not part of a workflow stage
  """
  workflowStage: PeriodWorkflowStage
}

"\n    The status of an application. This is usually a computed field, not stored in the database. The status\n    is computed based on the status of the appRequest and of the requirements for the program. If\n    the appRequest is CLOSED or CANCELLED, this status will remain frozen wherever it was before the\n    closure / cancellation.\n  "
enum ApplicationStatus {
  """
  An offer was made to the applicant and all ACCEPTANCE requirements are met (the applicant accepted the offer).
  """
  ACCEPTED

  """
  All application requirements up to and including WORKFLOW_BLOCKING requirements are resolving as MET (or NOT_APPLICABLE or WARNING). If there is an acceptance phase, the acceptance is still pending.
  """
  ELIGIBLE

  """
  At least one application requirement up to and including WORKFLOW_BLOCKING requirements is not met. The review cannot proceed, but the first or current stage of the workflow should still continue.
  """
  INELIGIBLE

  """
  The application status has not yet been determined. Further prompts must be answered.
  """
  PENDING

  """
  An offer was made to the applicant and at least one ACCEPTANCE requirement is not met (the applicant rejected the offer).
  """
  REJECTED
}

type Configuration {
  actions: ConfigurationAccess!
  data: JsonData!

  """The key being configured. Could be a requirement or prompt key."""
  key: String!
}

type ConfigurationAccess {
  update: Boolean!
  view: Boolean!
}

input ConfigurationFilters {
  """Return specific configurations."""
  ids: [ID!]

  """Return configurations for these keys."""
  keys: [String!]

  """Return configurations for these period codes."""
  periodCodes: [String!]

  """Return configurations for these period IDs."""
  periodIds: [ID!]
}

"""
Date and Time in ISO 8601 string format. JSON parser should convert to javascript Date type.
"""
scalar DateTime

type Groupings {
  """
  IDs are the unique values that may be used to group an items. Multiple IDs may be assigned to an item. i.e. ["Staff", "Faculty", "Student"]
  """
  ids: [String!]!

  """
  Label is the name of the grouping. Groupings are indexed to allow for quick filtering of a list of items. i.e. institutionalRoles
  """
  label: String!
}

"""
This represents an index as registered by one of the project's prompt definitions.
"""
type IndexCategory {
  """
  If this is > 0, the index values should be shown on the main app request list page, sorted by this priority in descending order.
  """
  appRequestListPriority: Float

  """
  If this is > 0, the index values should be shown on the applicant dashboard, sorted by this priority in descending order.
  """
  applicantDashboardPriority: Float
  category: String!
  categoryLabel: String!

  """
  If this is > 0, the index values should be shown on the list filters, sorted by this priority in descending order.
  """
  listFiltersPriority: Float
  listable: Boolean!

  """
  If this is > 0, the index values should be shown on the reviewer dashboard, sorted by this priority in descending order.
  """
  reviewerDashboardPriority: Float
  values(
    """
    If true, only return tags that are currently in use by app requests. This is useful for only presenting useful filters.
    """
    inUse: Boolean
    search: String
  ): [IndexValue!]!
}

type IndexValue {
  label: String!
  value: String!
}

enum IneligiblePhases {
  """The application became ineligible in the acceptance phase."""
  ACCEPTANCE

  """The application became ineligible in the approval phase."""
  APPROVAL

  """The application became ineligible in the pre-approval phase."""
  PREAPPROVAL

  """The application became ineligible in the pre-qualification phase."""
  PREQUAL

  """The application became ineligible in the qualification phase."""
  QUALIFICATION

  """The application became ineligible during blocking workflow."""
  WORKFLOW
}

"""Unstructured JSON data."""
scalar JsonData

type Mutation {
  """
  This is for the applicant to accept or reject the offer that was made based on their app request. The difference between accept and reject is determined by the status of the acceptance requirements. They will still "accept offer" after they answer that they do not want the offer. If there is non-blocking workflow on any applications, the first one in each will begin. Applications without non-blocking workflow will be advanced to the COMPLETE phase. If all applications are complete, the app request will be closed.
  """
  acceptOffer(appRequestId: ID!): ValidatedAppRequestResponse!

  """Add a note to the app request."""
  addNote(
    content: String!

    """
    If true, the note will be marked as internal and only visible to reviewers.
    """
    internal: Boolean!
  ): ValidatedAppRequestResponse!

  """
  Moves the application to the next workflow stage. If phase is READY_FOR_WORKFLOW, moves to the first or next blocking workflow stage. If on the last blocking workflow, moves to READY_FOR_OFFER. If all applications are READY_FOR_OFFER, automatically triggers the app request makeOffer mutation. If on the last non-blocking workflow, moves the application to COMPLETE. If all applications are COMPLETE, automatically triggers the app request close mutation.
  """
  advanceWorkflow(applicationId: ID!): ValidatedAppRequestResponse!

  """
  Cancel or withdraw the app request, depending on its current phase. This is only available if the app request is in a cancellable state.
  """
  cancelAppRequest(
    appRequestId: ID!

    """
    If the user is currently viewing some of the app request details, include the dataVersion here to make the cancellation fail when the app request has been updated by another user.
    """
    dataVersion: Int
  ): ValidatedAppRequestResponse!

  """
  Close the app request. Generally this is always available and will freeze the request/applications in their current phase/status.
  """
  closeAppRequest(appRequestId: ID!): ValidatedAppRequestResponse!

  """Create a new app request."""
  createAppRequest(login: String!, periodId: ID!, validateOnly: Boolean): ValidatedAppRequestResponse!
  createPeriod(copyPeriodId: String, period: PeriodUpdate!, validateOnly: Boolean): ValidatedPeriodResponse!
  deletePeriod(periodId: ID!): ValidatedResponse!

  """
  Make an offer on the app request. If all applications are ineligible, or if there are no acceptance requirements, the applications will advance to the non-blocking workflow, or absent that, be marked complete.
  """
  offerAppRequest(appRequestId: ID!): ValidatedAppRequestResponse!

  """
  Reopen the app request. This is only available if the app request is in a state that allows reopening.
  """
  reopenAppRequest(appRequestId: ID!): ValidatedAppRequestResponse!

  """
  Return the app request to the applicant phase. This is only available if the app request is in a state that allows returning.
  """
  returnAppRequest(appRequestId: ID!): ValidatedAppRequestResponse!
  roleAddGrant(grant: AccessRoleGrantCreate!, roleId: ID!, validateOnly: Boolean): AccessRoleValidatedResponse!
  roleCreate(role: AccessRoleInput!, validateOnly: Boolean): AccessRoleValidatedResponse!
  roleDelete(roleId: ID!): ValidatedResponse!
  roleDeleteGrant(grantId: ID!): AccessRoleValidatedResponse!
  roleUpdate(role: AccessRoleInput!, roleId: ID!, validateOnly: Boolean): AccessRoleValidatedResponse!
  roleUpdateGrant(grant: AccessRoleGrantUpdate!, grantId: ID!, validateOnly: Boolean): AccessRoleValidatedResponse!

  """Submit the app request."""
  submitAppRequest(appRequestId: ID!): ValidatedAppRequestResponse!
  updateConfiguration(data: JsonData!, key: String!, periodId: ID!, validateOnly: Boolean): ValidatedConfigurationResponse!
  updatePeriod(periodId: ID!, update: PeriodUpdate!, validateOnly: Boolean): ValidatedPeriodResponse!
  updatePeriodRequirement(disabled: Boolean!, periodId: String!, requirementKey: String!): ValidatedResponse!

  """Update the data for a prompt in this app request."""
  updatePrompt(
    data: JsonData!

    """
    The data version of the app request at the time this prompt was loaded. If provided, the API will perform an optimistic concurrency check and fail the update if someone else has updated the data in the meantime.
    """
    dataVersion: Int
    promptId: ID!
    validateOnly: Boolean
  ): ValidatedAppRequestResponse!
}

type MutationMessage {
  """
  The path to the arg that produced the error. Dot-separated (lodash.get compatible) if it is deep inside an input type. Null if no particular arg can be blamed for the error.
  """
  arg: String

  """
  An error message to be shown to the end user, with the context of the given arg.
  """
  message: String!

  """The type of error message. See the enum descriptions for more detail."""
  type: MutationMessageType!
}

enum MutationMessageType {
  """This error means the mutation cannot and/or did not take place."""
  error

  """
  This message should be shown to the end user before submission to let them know ahead of time that one of their entries passed validation (e.g. username available or password strength high).
  """
  success

  """
  The mutation can and/or did complete, but the user should receive the warning anyway (e.g. "Your password sucks but I'll allow it.").
  """
  warning
}

input Pagination {
  """The page number to retrieve. If not provided, will default to 1."""
  page: Int
  perPage: Int
}

type PaginationInfoWithTotalItems {
  """
  The current page number, starting at 1. This is always provided - if pagination was not requested, will return 1.
  """
  currentPage: Float!

  """
  List of indexed grouping data related to items within a page. Often used for filtering items.
  """
  groupings: [Groupings!]

  """
  Indicates whether requesting the next page would provide more results. Especially useful for models that cannot provide total item count for practical reasons. Note that over time, more results can appear and make this answer wrong, so in some circumstances it makes sense to request another page anyway.
  """
  hasNextPage: Boolean!

  """
  The number of items per page. Null if pagination was not requested/forced because results per page is unlimited.
  """
  perPage: Float

  """
  If possible, the total number of results will be provided. The API may return null if calculating the total is impractical. If pagination was not requested/forced, will equal the result count.
  """
  totalItems: Float
}

type PaginationResponse {
  accessUsers: PaginationInfoWithTotalItems
}

type Period {
  actions: PeriodActions!

  """
  This is useful for filtering out periods that are no longer useful. For instance, a window might close applications after 2 weeks but the reviewers could be working.
  """
  archiveDate: DateTime

  """
  Date that this period closes for applications. Some periods do not set a close date.
  """
  closeDate: DateTime

  """
  Unique identifier for this period that references an external system. Ideally human readable.
  """
  code: String
  configurations(filter: ConfigurationFilters): [Configuration!]!
  id: ID!

  """
  Name for this period. Will be displayed to applicants if they create an App Request while two periods are simultaneously open.
  """
  name: String!

  """Date that this period opens for applications."""
  openDate: DateTime!
  programs: [PeriodProgram!]!
  prompts: [PeriodPrompt!]!
  requirements: [PeriodProgramRequirement!]!

  """
  Whether this period's configurations have been reviewed by an administrator. Newly created periods must be reviewed before they will accept new app requests, even if the open date has passed.
  """
  reviewed: Boolean!
}

type PeriodActions {
  createAppRequest: Boolean!
  delete: Boolean!
  update: Boolean!
}

input PeriodFilters {
  """Return periods that will be archived after this date."""
  archiveAfter: DateTime

  """Return periods that were archived before this date."""
  archiveBefore: DateTime

  """Return periods that are open at this date or will be open after it."""
  closesAfter: DateTime

  """
  Return periods that closed before this date, not including that date's active period(s).
  """
  closesBefore: DateTime

  """Return periods that have any of these codes."""
  codes: [String!]

  """Return periods that have any of these IDs."""
  ids: [ID!]

  """Return periods that have any of these names."""
  names: [String!]

  """true -> open periods. false -> closed periods. null -> all periods."""
  openNow: Boolean

  """
  Return periods that open after this date, not including that date's active period(s).
  """
  opensAfter: DateTime

  """Return periods that are open at this date or have been open before it."""
  opensBefore: DateTime
}

type PeriodProgram {
  actions: PeriodProgramActions!

  """
  Whether the program is enabled in this period. This is set by the system administrator.
  """
  enabled: Boolean!
  key: ID!
  navTitle: String!
  period: Period!
  requirements: [PeriodProgramRequirement!]!
  title: String!
}

type PeriodProgramActions {
  configure: Boolean!
}

type PeriodProgramRequirement {
  """The configuration for this requirement in the period."""
  configuration: Configuration!

  """
  An internal description of the requirement. Probably not shown to users.
  """
  description: String!

  """
  Whether the requirement is enabled in this period. This is set by the system administrator.
  """
  enabled: Boolean!

  """
  A human and machine readable unique and stable identifier that we can use to add javascript logic to the evaluation of whether a requirement is satisfied. For example: "gi_ch33_must_be_post911"
  """
  key: String!

  """
  A human readable title for the requirement in the navigation. You probably want it to be shorter than the full title. If not provided, the title will be used.
  """
  navTitle: String!
  prompts: [PeriodPrompt!]!

  """
  A human readable title for the requirement. This is what will be shown to users.
  """
  title: String!

  """
  The type of requirement. This determines when the requirement is evaluated and who can see the requirement.
  """
  type: RequirementType!
}

type PeriodPrompt {
  """The configuration for this prompt in the given period."""
  configuration: Configuration!

  """
  A brief description of the prompt. This should be shown to administrators to help explain the full meaning of the prompt while assigning permissions or editing its configuration.
  """
  description: String

  """
  A human and machine readable identifier for the prompt. Will be used to match prompt data with UI and API code that handles it.
  """
  key: String!

  """
  A human readable title for the prompt in the navigation. You probably want it to be shorter than the full title. If not provided, the title will be used.
  """
  navTitle: String!
  periodId: String!

  """
  A human readable title for the prompt. This is what will be shown to users.
  """
  title: String!
}

input PeriodUpdate {
  archiveDate: DateTime
  closeDate: DateTime
  code: String
  name: String!
  openDate: DateTime!
  reviewed: Boolean
}

type PeriodWorkflowStage {
  """
  Whether this stage is blocking. If true, the application cannot be completed and shown to the applicant until all requirements in this stage are satisfied.
  """
  blocking: Boolean!

  """
  Globally unique key for this workflow stage. Use lowercase snake_case, alphanumeric and underscore only.
  """
  key: String!

  """A human readable title for the workflow stage."""
  title: String!
}

type Program {
  key: ID!
  navTitle: String!
  title: String!
}

input ProgramFilters {
  keys: [String!]
}

"""
The visibility of a prompt on a request. This is used to determine whether the prompt should be shown to the user in the UI.
"""
enum PromptVisibility {
  """
  This RequirementPrompt is a duplicate of a RequirementPrompt that already appears earlier in the same application (it could also be duplicated yet again in an earlier application). It should not be shown to applicants. The reviewer UI may or may not want to show these repeated dependencies.
  """
  APPLICATION_DUPE

  """
  This RequirementPrompt is available to be answered. It is the first appearance of this prompt in the App Request. It should be visible in both the applicant and reviewer UI.
  """
  AVAILABLE

  """
  This RequirementPrompt is a duplicate of a RequirementPrompt that already appears earlier in the same app request, but it is the first appearance in its application. It should not be shown to applicants. The reviewer UI may or may not want to show these repeated dependencies.
  """
  REQUEST_DUPE

  """
  This RequirementPrompt cannot be reached, there is a requirement or prompt in front of it that could or already has disqualified the application.
  """
  UNREACHABLE
}

type Query {
  "\n    This is the global access object. Each field represents a global permission\n    like the ability to view the role management interface.\n  "
  access: Access!
  accessUsers(filter: AccessUserFilter, paged: Pagination): [AccessUser!]!
  appRequestIndexes(
    categories: [String!]

    """
    Returns indexes that are flagged to appear in this destination. Also sorts for this destination.
    """
    for: AppRequestIndexDestination
  ): [IndexCategory!]!
  appRequests(filter: AppRequestFilter): [AppRequest!]!

  """
  This is where you get information about the authorization system. Each grant will be associated with one of these controlGroups, one or more controls in the group, and an optional set of tags. The tags are used to limit the scope of the grant.
  """
  controlGroups: [AccessControlGroup!]!
  pageInfo: PaginationResponse!
  periods(filter: PeriodFilters): [Period!]!
  programs(filter: ProgramFilters): [Program!]!
  roles(filter: AccessRoleFilter): [AccessRole!]!

  """
  A list of all possible scopes. Scopes are used to limit users when they are accessing the system through an alternate UI or login method. For instance, if you generate an authentication token to give to a third party, it may have a scope identifying that third party and limiting their access even though they are acting as you. Roles must match the token scope in order to apply permissions.
  """
  scopes: [String!]!
}

"""
A RequestPrompt is an instance of a Prompt on a particular request. Once the user has answered the prompt, it contains the answer and the prompt status on that request.
"""
type RequirementPrompt {
  """Actions that the user can take on this prompt."""
  actions: RequirementPromptActions!

  """Whether the prompt has been answered on this request."""
  answered: Boolean!

  """The configuration data for this prompt in the app request's period."""
  configurationData: JsonData

  """
  All the configuration data that could be relevant for this prompt. This includes its own config, and also the config data for any requirements and programs that are related to it.
  """
  configurationRelatedData: JsonData!

  """
  The data that has been gathered from the user in response to this prompt. The schema is controlled by the question's implementation.
  """
  data(
    """
    Provide the schemaVersion at the time the UI was built. Will throw an error if the client is too old, so it knows to refresh.
    """
    schemaVersion: String
  ): JsonData

  """
  A brief description of the prompt. This should be shown to administrators to help explain the full meaning of the prompt while assigning permissions or editing its configuration.
  """
  description: String

  """
  Any data that the API needs to provide to the UI to display the prompt properly. For instance, if the prompt text is in the database and able to be modified by admins, the UI can't hardcode the prompt text and needs it from the API. Could also be used to pull reference information from an external system, e.g. a student's course schedule, for display in the prompt dialog.
  """
  fetchedData(
    """
    Provide the schemaVersion at the time the UI was built. Will throw an error if the client is too old, so it knows to refresh.
    """
    schemaVersion: String
  ): JsonData
  id: ID!

  """
  When true, this prompt has been invalidated by the answer to another prompt. The `answered` field should remain false until the user specifically answers this prompt again, regardless of the output of the definition's `complete` method.
  """
  invalidated: Boolean!

  """
  If the prompt has been invalidated, this may contain a reason why. It should be displayed to the user.
  """
  invalidatedReason: String

  """
  A human and machine readable identifier for the prompt. Will be used to match prompt data with UI and API code that handles it.
  """
  key: String!

  """
  This prompt's requirement follows a requirement that has already marked the application as ineligible. The prompt still has visibility of AVAILABLE OR REQUEST_DUPE OR APPLICATION_DUPE as normal, but should probably be shown to the user as disabled or not shown at all.
  """
  moot: Boolean!

  """
  A human readable title for the prompt in the navigation. You probably want it to be shorter than the full title. If not provided, the title will be used.
  """
  navTitle: String!

  """
  Preload data that has been generated according to the prompt definition. For example, a prompt might query the database for answers given in previous requests or query an external API to learn facts about the user.
  """
  preloadData(
    """
    Provide the schemaVersion at the time the UI was built. Will throw an error if the client is too old, so it knows to refresh.
    """
    schemaVersion: String
  ): JsonData

  """The requirement that this prompt is associated with."""
  requirement: ApplicationRequirement!

  """
  A human readable title for the prompt. This is what will be shown to users.
  """
  title: String!

  """
  The visibility of the prompt on the request. This is used to determine whether the prompt should be shown to the user in the UI.
  """
  visibility: PromptVisibility!
}

type RequirementPromptActions {
  update: Boolean!
}

enum RequirementStatus {
  """
  The requirement has not been met, and it means the application is denied/ineligible.
  """
  DISQUALIFYING

  """The requirement has been met."""
  MET

  """
  The requirement is not applicable. The application should not yet be denied, proceed to the next requirement.
  """
  NOT_APPLICABLE

  """
  The requirement cannot be evaluated yet because one or more questions are unanswered.
  """
  PENDING

  """
  The requirement has not been met, but the application may still be approved. The requirement should be marked in some way as not quite satisfactory. The statusReason may explain further what is wrong.
  """
  WARNING
}

enum RequirementType {
  """
  A requirement that should only be shown to applicants after the application has been through review and an offer has been made. The applicant can come back and fill out the requirement's prompts to accept the offer.
  """
  ACCEPTANCE

  """
  A requirement that should only be shown to agents/reviewers and must have a non-pending status before an application is closed.
  """
  APPROVAL

  """
  A requirement that should be shown to applicants at the end of the request process, prior to review and submission, outside the context of the individual programs. It is intended for acknowledgements like "I affirm that I have given truthful answers". It wouldn't make sense to have them affirm that their answers are truthful in one application but not in the others.
  """
  POSTQUAL

  """
  A requirement that has no prompts and must have a non-PENDING status before an application may be reviewed. Use this for materials/data that must appear in an external system before a reviewer will be able to begin their work.
  """
  PREAPPROVAL

  """
  A requirement that should have a non-PENDING status before the user is shown their programs. Only the applications for programs whose PREQUAL requirements are MET or NOT_APPLICABLE should be visible. The others should be entirely hidden, rather than being shown in a disabled/ineligible state.
  """
  PREQUAL

  """
  A requirement that should have a non-pending status before an application may be submitted for review. Programs with a DISQUALIFYING requirement of type APPLICATION should be visible to the submitter but visually distinct as disabled/ineligible.
  """
  QUALIFICATION

  """
  This requirement belongs to a workflow stage. It should only be included in a workflow stage and should not appear in the standard requirementKeys array of a program.
  """
  WORKFLOW
}

type RoleActions {
  delete: Boolean!
  update: Boolean!
}

type ValidatedAppRequestResponse {
  appRequest: AppRequest
  messages: [MutationMessage!]!

  """
  True if the mutation succeeded (e.g. saved data or passed validation), even if there were warnings.
  """
  success: Boolean!
}

type ValidatedConfigurationResponse {
  configuration: Configuration
  messages: [MutationMessage!]!

  """
  True if the mutation succeeded (e.g. saved data or passed validation), even if there were warnings.
  """
  success: Boolean!
}

type ValidatedPeriodResponse {
  messages: [MutationMessage!]!
  period: Period

  """
  True if the mutation succeeded (e.g. saved data or passed validation), even if there were warnings.
  """
  success: Boolean!
}

type ValidatedResponse {
  messages: [MutationMessage!]!

  """
  True if the mutation succeeded (e.g. saved data or passed validation), even if there were warnings.
  """
  success: Boolean!
}