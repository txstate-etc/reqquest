type Access {
  createPeriod: Boolean!

  """
  Current user is permitted to create new roles in the role management UI.
  """
  createRole: Boolean!
  viewApplicantInterface: Boolean!
  viewDefinitionManagement: Boolean!
  viewPeriodManagement: Boolean!
  viewReviewerInterface: Boolean!

  """Current user is permitted to view the role management UI."""
  viewRoleManagement: Boolean!
}

type AccessControl {
  description: String!
  name: String!
  tagType: AccessSearchType!

  """
  A list of all possible tags for the control. Null if tagging is not supported for the control.
  """
  tags(search: String): [AccessTag!]
}

input AccessControlInput {
  """The action this grant applies to, e.g. "view" or "update"."""
  control: String!

  """A list of tags to help res"""
  tags: [AccessTagInput!]!
}

type AccessRole {
  actions: RoleActions!
  grants: [AccessRoleGrant!]!
  groups: [String!]!
  id: ID!
  name: String!
  scope: String
}

input AccessRoleFilter {
  groups: [String!]
  ids: [ID!]
  names: [String!]
  scopes: [String!]
}

type AccessRoleGrant {
  "\n    If true, this grant allows the action specified by the selected controls. If false, it removes\n    the controls.\n\n    Removing a control only happens within the context of a single role. If another role grants the\n    same control, the action is allowed. This is more of an exception system than a denial\n    system. So you can do something like add the \"view\" control to the \"movie\" subject type in one\n    grant, and then in a second grant in the same role, remove it from \"The Princess Bride\". Now you\n    have a role that grants \"view\" on all movies _except_ The Princess Bride. If the user has another role\n    that grants \"view\" on The Princess Bride (or on all movies), they can view it based on that other role.\n  "
  allow: Boolean!
  id: ID!

  "\n    The specific subject instance this grant applies to, e.g. if subjectType is \"movie\",\n    subject might be \"The Princess Bride\", and the grant applies to that movie. If null,\n    the grant applies to all movies. It's a little more complicated than that when we consider\n    the \"allow\" setting, see that description for more details.\n  "
  subject: String

  """The type of subject this grant applies to, e.g. "movie"."""
  subjectType: String!
}

input AccessRoleGrantCreate {
  allow: Boolean!
  controls: [AccessControlInput!]!
  description: String
  subjectType: String!

  """A list of subject IDs to restrict the grant."""
  subjects: [String!]
}

input AccessRoleInput {
  """A list of groups this role is associated with."""
  groups: [String!]!
  name: String!

  """Attach this role to a specific authentication scope, e.g. "parent"."""
  scope: String
}

type AccessRoleValidatedResponse {
  accessRole: AccessRole
  messages: [MutationMessage!]!

  """
  True if the mutation succeeded (e.g. saved data or passed validation), even if there were warnings.
  """
  success: Boolean!
}

"""The way that this list should be interacted with."""
enum AccessSearchType {
  """
  There will never be objects in the list. Do not create a UI to interact with the list at all.
  """
  NONE

  """
  The list will be too large for the user to browse through, or simply not feasible to list exhaustively, so we let the user search for list items.
  """
  SEARCH

  """
  The list will be small enough to make the user browse the whole list and add items by selection.
  """
  SELECT
}

type AccessSubjectInstance {
  id: ID!
  name: String!
}

type AccessSubjectType {
  """
  A list of all possible controls for this subjectType. Use this to populate the control dropdown when creating a grant.
  """
  controls: [AccessControl!]!
  name: String!

  """The way that subject instances are added to the grant."""
  subjectSearchType: AccessSearchType!

  """
  A list of all possible instances of this subjectType. Use this to populate the subject dropdown when creating a grant.
  """
  subjects(
    """
    Set this arg to filter the list based on the search. If this subjectType is not marked as searchable, this search will be ignored. If it is marked as searchable, an empty search will probably not return any instances (but it is up to the implementation of the subjectType).
    """
    search: String
  ): [AccessSubjectInstance!]!
}

type AccessTag {
  category: String
  categoryLabel: String
  name: String!
  tag: String!
}

input AccessTagInput {
  """The category this tag belongs to, e.g. "State"."""
  category: String!

  """The tag value, e.g. "TX"."""
  tag: String!
}

"""A user that has or once had access to the system."""
type AccessUser {
  groups: [String!]!
  login: ID!
  otherIdentifiers: [AccessUserIdentifier!]!

  """
  A JSON object containing any information about the user that the implementing application wants to store. Could be useful for constructing personalized UI.
  """
  otherInfo: JsonData
  roles: AccessRole!
}

input AccessUserFilter {
  logins: [ID!]
  otherIdentifersByLabel: [AccessUserIdentifierInput!]
  otherIdentifiers: [String!]
  search: String
}

"""
A label and ID pair for an external user unique ID. For example, { label: "Student ID", id: "123456" }
"""
type AccessUserIdentifier {
  """The unique ID for this identifier, e.g. "123456"."""
  id: ID!

  """The label for this identifier, e.g. "Student ID"."""
  label: String!
}

"""
A label and ID pair for an external user unique ID. For example, { label: "Student ID", id: "123456" }
"""
input AccessUserIdentifierInput {
  id: ID!
  label: String!
}

"""
Represents a group of applications all being applied for at the same time. As part of the request, multiple applications will be created and either eliminated as ineligible or submitted for approval.
"""
type AppRequest {
  applications: [Application!]!

  """
  Date that this request was considered closed and no longer editable. If active or re-opened, will be null. If closed again, will be the second closure date.
  """
  closedAt: DateTime
  createdAt: DateTime!

  """
  All data that has been gathered from the user for this request. It is a Record whose properties are the prompt keys and values are the data gathered by the corresponding prompt dialog.
  """
  data(
    """
    Provide the schemaVersion at the time the UI was built. Will throw an error if the client is too old, so it knows to refresh.
    """
    schemaVersion: String
  ): JsonData!
  id: ID!

  """The period this appRequest is associated with."""
  period: Period!
  status: AppRequestStatus!
  updatedAt: DateTime!
}

input AppRequestFilter {
  ids: [ID!]

  """Only return appRequests that are owned by one the given logins."""
  logins: [ID!]

  """Only return appRequests that are owned by the current user."""
  own: Boolean
  periodIds: [ID!]
  status: [AppRequestStatus!]
}

"\n    The status of an appRequest. This status is computed based on the \"dbStatus\" recorded in\n    the database and the status of each application.\n  "
enum AppRequestStatus {
  """
  Applicant has submitted and any pre-approval requirements have been met. We are waiting for a reviewer to do their part.
  """
  APPROVAL

  """
  Applicant has submitted and at least one application is in an approved non-pending state. The request is not closed, so the status can still be changed. The reviewer should close out the request when ready, or the system will do it after the period ends.
  """
  APPROVED

  """
  The request has been closed and at least one application was approved. The request must be re-opened (if eligible) to be edited again.
  """
  APPROVED_CLOSED

  """
  Applicant cancelled the request before submitting. The applicant may be permitted to uncancel and continue, if the period is still open.
  """
  CANCELLED

  """
  Applicant has submitted and ALL applications have been disqualified. The request is not closed, so the status can still be changed. The reviewer should close out the request when ready, or the system will do it after the period ends.
  """
  DISQUALIFIED

  """
  The request has been closed and all applications were disqualified. The request must be re-opened (if eligible) to be edited again.
  """
  DISQUALIFIED_CLOSED

  """
  Applicant has submitted and we are waiting for pre-approval requirements to resolve (usually these are automations like waiting for data to show up in an external system).
  """
  PREAPPROVAL

  """
  Applicant has completed the process and is ready to submit. At least one application is eligible to proceed.
  """
  READY_TO_SUBMIT

  """Applicant has begun the process and has not yet submitted."""
  STARTED

  """
  Applicant withdrew the request after submitting. The request must be re-opened (if eligible) to be edited again.
  """
  WITHDRAWN
}

"""
An application represents the applicant applying to a specific program. Each appRequest has multiple applications - one per program defined in the system. Some applications are mutually exclusive and/or will be eliminated early based on PREQUAL requirements, but they all technically exist in the data model - there is no concept of picking one application over another, just two applications where one dies and the other survives.
"""
type Application {
  actions: ApplicationActions!
  id: ID!

  """The navigation title of the program this application is for."""
  navTitle: String!
  requirements: [ApplicationRequirement!]!
  status: ApplicationStatus!

  """
  When one of the application's requirements is failing or throwing a warning, its reason will be copied here for convenience. If there is a warning and then later a failure, the failure reason will win.
  """
  statusReason: String

  """The title of the program this application is for."""
  title: String!
}

type ApplicationActions {
  viewAsReviewer: Boolean!
}

"""
The specific instance of a requirement on a particular application. Stores the status of the requirement, e.g. being satisfied or not.
"""
type ApplicationRequirement {
  application: Application!

  """
  The configuration data for this requirement in the app request's period.
  """
  configurationData: JsonData

  """
  An internal description of the requirement. Probably not shown to users.
  """
  description: String!
  id: ID!

  """
  A human and machine readable unique and stable identifier that we can use to add javascript logic to the evaluation of whether a requirement is satisfied. For example: "gi_ch33_must_be_post911"
  """
  key: String!

  """
  A human readable title for the requirement in the navigation. You probably want it to be shorter than the full title. If not provided, the title will be used.
  """
  navTitle: String!
  prompts: [RequirementPrompt!]!

  """
  When true, means that the requirement has not been made moot by an earlier requirement failing. It may still need to be hidden from navigation based on evaluatedInEarlierApplication.
  """
  reachable: Boolean!

  """
  The smart title for this requirement in the app request's period. For instance, might be "Applicant must have GPA over 3.4" instead of the regular title "Applicant must meet GPA requirement". Will fall back to the regular title for any requirement that does not provide a smart title.
  """
  smartTitle: String!

  """The status of the requirement. This is what will be shown to users."""
  status: RequirementStatus!

  """
  The reason why the requirement is in the status it is in. This will be shown to the applicant.
  """
  statusReason: String

  """
  A human readable title for the requirement. This is what will be shown to users.
  """
  title: String!

  """
  The type of requirement. This determines when the requirement is evaluated and who can see the requirement.
  """
  type: RequirementType!
}

"\n    The status of an application. This is usually a computed field, not stored in the database. The status\n    is computed based on the status of the appRequest and of the requirements for the program. If\n    the appRequest is CLOSED, the status should permanently match the ApplicationStatusDB instead of being\n    computed. If the appRequest is CANCELLED, all applications should be CANCELLED as well.\n  "
enum ApplicationStatus {
  """
  The application's benefit has been accepted by the applicant. This status is only possible for programs with at least one ACCEPTANCE requirement.
  """
  ACCEPTED

  """
  The application has been submitted, has passed preapproval, and is awaiting approval.
  """
  APPROVAL

  """The application has been approved."""
  APPROVED

  "\n      The appRequest (and thus the application inside it) has been cancelled by the applicant. In\n      some cases, individual programs may have a requirement that the applicant agrees that they\n      desire to apply. In that case the appRequest status is not CANCELLED, and neither is the application\n      status. It will actually be FAILED_PREQUAL or FAILED_QUALIFICATION, and the statusReason of the\n      requirement will explain that the applicant did not wish to pursue the application.\n    "
  CANCELLED

  """
  The applicant is ineligible for the program according to the pre-qual requirements. The application/program should no longer be visible in the UI for this appRequest.
  """
  FAILED_PREQUAL

  """
  The applicant is ineligible for the program according to the qualification requirements. The application/program should remain visible in the UI and any applicable statusReason from the associated requirements should be displayed.
  """
  FAILED_QUALIFICATION

  """
  The application's benefit was rejected by the applicant. This status is only possible for programs with at least one ACCEPTANCE requirement.
  """
  NOT_ACCEPTED

  """The application has not been approved."""
  NOT_APPROVED

  """The application has been submitted and is awaiting preapproval."""
  PREAPPROVAL

  """
  The appRequest has not finished pre-qualification yet. This application does not quite exist yet and probably should not appear in the UI.
  """
  PREQUAL

  """
  The application has been pre-qualified and is awaiting further input from the applicant.
  """
  QUALIFICATION

  """
  All requirements have been evaluated as MET or NOT_APPLICABLE. The application is ready to be submitted.
  """
  READY_TO_SUBMIT

  """
  The appRequest (and thus the application inside it) was withdrawn after being submitted. If it is re-opened, it will re-open in submitted state.
  """
  WITHDRAWN
}

type Configuration {
  actions: ConfigurationAccess!
  data: JsonData!

  """The key being configured. Could be a requirement or prompt key."""
  key: String!
}

type ConfigurationAccess {
  update: Boolean!
  view: Boolean!
}

input ConfigurationFilters {
  """Return specific configurations."""
  ids: [ID!]

  """Return configurations for these keys."""
  keys: [String!]

  """Return configurations for these period codes."""
  periodCodes: [String!]

  """Return configurations for these period IDs."""
  periodIds: [ID!]
}

"""
Date and Time in ISO 8601 string format. JSON parser should convert to javascript Date type.
"""
scalar DateTime

"""Unstructured JSON data."""
scalar JsonData

type Mutation {
  roleAddGrant(grant: AccessRoleGrantCreate!, roleId: ID!, validateOnly: Boolean): AccessRoleValidatedResponse!
  roleCreate(role: AccessRoleInput!, validateOnly: Boolean): AccessRoleValidatedResponse!
  roleDelete(roleId: ID!): ValidatedResponse!
  roleDeleteGrant(grantId: ID!): AccessRoleValidatedResponse!
  roleUpdate(role: AccessRoleInput!, roleId: ID!, validateOnly: Boolean): AccessRoleValidatedResponse!
  roleUpdateGrant(grant: AccessRoleGrantCreate!, grantId: ID!, validateOnly: Boolean): AccessRoleValidatedResponse!

  """Submit the app request."""
  submitAppRequest(appRequestId: ID!): ValidatedAppRequestResponse!
  updateConfiguration(data: JsonData!, key: String!, periodId: String!, validateOnly: Boolean): ValidatedConfigurationResponse!
  updatePeriod(id: String!, update: PeriodUpdate!, validateOnly: Boolean): ValidatedPeriodResponse!

  """Update the data for a prompt in this app request."""
  updatePrompt(data: JsonData!, promptId: ID!, validateOnly: Boolean): ValidatedAppRequestResponse!
}

type MutationMessage {
  """
  The path to the arg that produced the error. Dot-separated (lodash.get compatible) if it is deep inside an input type. Null if no particular arg can be blamed for the error.
  """
  arg: String

  """
  An error message to be shown to the end user, with the context of the given arg.
  """
  message: String!

  """The type of error message. See the enum descriptions for more detail."""
  type: MutationMessageType!
}

enum MutationMessageType {
  """This error means the mutation cannot and/or did not take place."""
  error

  """
  This message should be shown to the end user before submission to let them know ahead of time that one of their entries passed validation (e.g. username available or password strength high).
  """
  success

  """
  The mutation can and/or did complete, but the user should receive the warning anyway (e.g. "Your password sucks but I'll allow it.").
  """
  warning
}

type Period {
  actions: PeriodActions!

  """
  This is useful for filtering out periods that are no longer useful. For instance, a window might close applications after 2 weeks but the reviewers could be working.
  """
  archiveAt: DateTime

  """Date that this period closes for applications."""
  closeDate: DateTime!

  """
  Unique identifier for this period that references an external system. Ideally human readable.
  """
  code: String
  configurations(filter: ConfigurationFilters): [Configuration!]!
  id: ID!

  """
  Name for this period. Will be displayed to applicants if they create an App Request while two periods are simultaneously open.
  """
  name: String!

  """Date that this period opens for applications."""
  openDate: DateTime!
  programs: [PeriodProgram!]!
  prompts: [PeriodPrompt!]!
  requirements: [PeriodProgramRequirement!]!
}

type PeriodActions {
  update: Boolean!
  view: Boolean!
}

input PeriodFilters {
  """Return periods that will be archived after this date."""
  archiveAfter: DateTime

  """Return periods that were archived before this date."""
  archiveBefore: DateTime

  """Return periods that are open at this date or will be open after it."""
  closesAfter: DateTime

  """
  Return periods that closed before this date, not including that date's active period(s).
  """
  closesBefore: DateTime

  """Return periods that have any of these codes."""
  codes: [String!]

  """Return periods that have any of these IDs."""
  ids: [ID!]

  """true -> open periods. false -> closed periods. null -> all periods."""
  openNow: Boolean

  """
  Return periods that open after this date, not including that date's active period(s).
  """
  opensAfter: DateTime

  """Return periods that are open at this date or have been open before it."""
  opensBefore: DateTime
}

type PeriodProgram {
  actions: PeriodProgramActions!

  """
  Whether the program is enabled in this period. This is set by the system administrator.
  """
  enabled: Boolean!
  group: PeriodProgramActions!
  key: ID!
  navTitle: String!
  period: Period!
  requirements: [PeriodProgramRequirement!]!
  title: String!
}

type PeriodProgramActions {
  configure: Boolean!
}

type PeriodProgramRequirement {
  """The configuration for this requirement in the period."""
  configuration: Configuration!

  """
  An internal description of the requirement. Probably not shown to users.
  """
  description: String!

  """
  Whether the requirement is enabled in this period. This is set by the system administrator.
  """
  enabled: Boolean!

  """
  A human and machine readable unique and stable identifier that we can use to add javascript logic to the evaluation of whether a requirement is satisfied. For example: "gi_ch33_must_be_post911"
  """
  key: String!

  """
  A human readable title for the requirement in the navigation. You probably want it to be shorter than the full title. If not provided, the title will be used.
  """
  navTitle: String!
  prompts: [PeriodPrompt!]!

  """
  A human readable title for the requirement. This is what will be shown to users.
  """
  title: String!

  """
  The type of requirement. This determines when the requirement is evaluated and who can see the requirement.
  """
  type: RequirementType!
}

type PeriodPrompt {
  """The configuration for this prompt in the given period."""
  configuration: Configuration!

  """
  A brief description of the prompt. This should be shown to administrators to help explain the full meaning of the prompt while assigning permissions or editing its configuration.
  """
  description: String

  """
  A human and machine readable identifier for the prompt. Will be used to match prompt data with UI and API code that handles it.
  """
  key: String!

  """
  A human readable title for the prompt in the navigation. You probably want it to be shorter than the full title. If not provided, the title will be used.
  """
  navTitle: String!
  periodId: String!

  """
  A human readable title for the prompt. This is what will be shown to users.
  """
  title: String!
}

input PeriodUpdate {
  archiveAt: DateTime
  closeDate: DateTime
  code: String
  name: String
  openDate: DateTime
}

type Program {
  key: ID!
  navTitle: String!
  title: String!
}

input ProgramFilters {
  keys: [String!]
}

type ProgramGroup {
  key: ID!

  """
  A human readable title for the program group in the navigation. You may want it to be shorter than the full title. If not provided, the title will be used.
  """
  navTitle: String!
  programs(filter: ProgramFilters): [Program!]!

  """
  A human readable title for the program group. This will be shown to users.
  """
  title: String!
}

input ProgramGroupFilter {
  keys: [ID!]
}

type Query {
  "\n    This is the global access object. Each field represents a global permission\n    like the ability to view the role management interface.\n  "
  access: Access!
  accessUsers(filter: AccessUserFilter): [AccessUser!]!
  appRequests(filter: AppRequestFilter): [AppRequest!]!
  periods(filter: PeriodFilters): [Period!]!
  programGroups(filter: ProgramGroupFilter): [ProgramGroup!]!
  programs(filter: ProgramFilters): [Program!]!
  roles(filter: AccessRoleFilter): [AccessRole!]!

  """
  This is where you get information about the authorization system. Each grant will be associated with one of these subjectTypes and optionally a list of subject instances. The grant will also have a set of controls, and each control will have an optional set of tags. The tags are used to limit the scope of the grant.
  """
  subjectTypes: [AccessSubjectType!]!
}

"""
A RequestPrompt is an instance of a Prompt on a particular request. Once the user has answered the prompt, it contains the answer and the prompt status on that request.
"""
type RequirementPrompt {
  """Whether the prompt has been answered on this request."""
  answered: Boolean!

  """
  For convenience, this is true if either askedInEarlierRequirement or askedInEarlierApplication is true.
  """
  askedEarlier: Boolean!

  """
  When true, means that this prompt should be hidden from navigation due to being asked in an earlier application. If a screen were reviewing the details of a single application, this prompt's information might re-appear in that context.
  """
  askedInEarlierApplication: Boolean!

  """
  When true, means that this prompt should be hidden from navigation due to being asked in an earlier requirement in the same application. If a screen were reviewing the details of a single requirement, this prompt's information might re-appear in that context.
  """
  askedInEarlierRequirement: Boolean!

  """The configuration data for this prompt in the app request's period."""
  configurationData: JsonData!

  """
  The data that has been gathered from the user in response to this prompt. The schema is controlled by the question's implementation.
  """
  data(
    """
    Provide the schemaVersion at the time the UI was built. Will throw an error if the client is too old, so it knows to refresh.
    """
    schemaVersion: String
  ): JsonData

  """
  A brief description of the prompt. This should be shown to administrators to help explain the full meaning of the prompt while assigning permissions or editing its configuration.
  """
  description: String

  """
  Any data that the API needs to provide to the UI to display the prompt properly. For instance, if the prompt text is in the database and able to be modified by admins, the UI can't hardcode the prompt text and needs it from the API. Could also be used to pull reference information from an external system, e.g. a student's course schedule, for display in the prompt dialog.
  """
  fetchedData(
    """
    Provide the schemaVersion at the time the UI was built. Will throw an error if the client is too old, so it knows to refresh.
    """
    schemaVersion: String
  ): JsonData

  """
  For convenience, this is true if the prompt is not reachable or has been asked earlier.
  """
  hiddenInNavigation: Boolean!
  id: ID!

  """
  When true, this prompt has been invalidated by the answer to another prompt. The `answered` field should remain false until the user specifically answers this prompt again, regardless of the output of the definition's `complete` method.
  """
  invalidated: Boolean!

  """
  A human and machine readable identifier for the prompt. Will be used to match prompt data with UI and API code that handles it.
  """
  key: String!

  """
  A human readable title for the prompt in the navigation. You probably want it to be shorter than the full title. If not provided, the title will be used.
  """
  navTitle: String!

  """
  Preload data that has been generated according to the prompt definition. For example, a prompt might query the database for answers given in previous requests or query an external API to learn facts about the user.
  """
  preloadData(
    """
    Provide the schemaVersion at the time the UI was built. Will throw an error if the client is too old, so it knows to refresh.
    """
    schemaVersion: String
  ): JsonData

  """
  When true, means that the prompt has not been made moot by an earlier requirement failing. It may still need to be hidden from navigation based on askedInEarlierRequirement or askedInEarlierApplication.
  """
  reachable: Boolean!

  """
  A human readable title for the prompt. This is what will be shown to users.
  """
  title: String!
}

enum RequirementStatus {
  """
  The requirement has not been met, and it means the application is denied/ineligible.
  """
  DISQUALIFYING

  """The requirement has been met."""
  MET

  """
  The requirement is not applicable. The application should not yet be denied, proceed to the next requirement.
  """
  NOT_APPLICABLE

  """
  The requirement cannot be evaluated yet because one or more questions are unanswered.
  """
  PENDING

  """
  The requirement has not been met, but the application may still be approved. The requirement should be marked in some way as not quite satisfactory. The statusReason may explain further what is wrong.
  """
  WARNING
}

enum RequirementType {
  """
  A requirement that should only be shown to agents/reviewers and must have a non-pending status before an application is closed.
  """
  APPROVAL

  """
  A requirement that has no prompts and must have a non-PENDING status before an application may be reviewed. Use this for materials/data that must appear in an external system before a reviewer will be able to begin their work.
  """
  PREAPPROVAL

  """
  A requirement that should have a non-PENDING status before the user is shown their programs. Only the applications for programs whose PREQUAL requirements are MET or NOT_APPLICABLE should be visible. The others should be entirely hidden, rather than being shown in a disabled/ineligible state.
  """
  PREQUAL

  """
  A requirement that should have a non-pending status before an application may be submitted for review. Programs with a DISQUALIFYING requirement of type APPLICATION should be visible to the submitter but visually distinct as disabled/ineligible.
  """
  QUALIFICATION
}

type RoleActions {
  delete: Boolean!
  update: Boolean!
  view: Boolean!
}

type ValidatedAppRequestResponse {
  appRequest: AppRequest!
  messages: [MutationMessage!]!

  """
  True if the mutation succeeded (e.g. saved data or passed validation), even if there were warnings.
  """
  success: Boolean!
}

type ValidatedConfigurationResponse {
  configuration: Configuration
  messages: [MutationMessage!]!

  """
  True if the mutation succeeded (e.g. saved data or passed validation), even if there were warnings.
  """
  success: Boolean!
}

type ValidatedPeriodResponse {
  messages: [MutationMessage!]!
  period: Period

  """
  True if the mutation succeeded (e.g. saved data or passed validation), even if there were warnings.
  """
  success: Boolean!
}

type ValidatedResponse {
  messages: [MutationMessage!]!

  """
  True if the mutation succeeded (e.g. saved data or passed validation), even if there were warnings.
  """
  success: Boolean!
}