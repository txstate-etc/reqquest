type Access {
  """
  Current user may create a new app request, either for themselves or on behalf of another user.
  """
  createAppRequest: Boolean!

  """
  Current user is permitted to create new periods in the period management UI.
  """
  createPeriod: Boolean!

  """
  Current user is permitted to create new roles in the role management UI.
  """
  createRole: Boolean!

  """Current user is permitted to view the app request list."""
  viewAppRequestList: Boolean!

  """Current user is permitted to view the applicant dashboard."""
  viewApplicantDashboard: Boolean!

  """Current user is permitted to view the period management UI."""
  viewPeriodManagement: Boolean!

  """Current user is permitted to view the reviewer dashboard."""
  viewReviewerInterface: Boolean!

  """Current user is permitted to view the role management UI."""
  viewRoleManagement: Boolean!
}

type AccessControl {
  description: String!
  name: String!
}

type AccessGrantTag {
  category: String!
  categoryLabel: String!
  label: String!
  tag: String!
}

type AccessRole {
  actions: RoleActions!

  """
  A description of the grant. This is not used for anything, but can be useful for admins to understand what the grant was trying to do.
  """
  description: String
  grants: [AccessRoleGrant!]!
  groups: [String!]!
  id: ID!
  name: String!
  scope: String
}

input AccessRoleFilter {
  groups: [String!]
  ids: [ID!]
  names: [String!]
  scopes: [String!]
}

type AccessRoleGrant {
  actions: AccessRoleGrantActions!

  "\n    If true, this grant allows the action specified by the selected controls. If false, it removes\n    the controls.\n\n    Removing a control only happens within the context of a single role. If another role grants the\n    same control, the action is allowed. This is more of an exception system than a denial\n    system. So you can do something like add the \"view\" control to the \"movie\" subject type in one\n    grant, and then in a second grant in the same role, remove it from \"The Princess Bride\". Now you\n    have a role that grants \"view\" on all movies _except_ The Princess Bride. If the user has another role\n    that grants \"view\" on The Princess Bride (or on all movies), they can view it based on that other role.\n  "
  allow: Boolean!
  controls: [String!]!
  id: ID!

  """The type of subject this grant applies to, e.g. "movie"."""
  subjectType: AccessSubjectType!
  tags: [AccessGrantTag!]!
}

type AccessRoleGrantActions {
  delete: Boolean!
  update: Boolean!
}

input AccessRoleGrantCreate {
  allow: Boolean!

  """
  A list of controls that are allowed or denied by this grant. Each subjectType has a list of available controls, available under Query.subjectTypes.
  """
  controls: [String!]
  subjectType: String

  """
  A list of tags to restrict a grant. For instance, if this is added to a grant on PromptAnswer-update, each tag refers to a subset of App Requests.
  """
  tags: [AccessTagInput!]
}

input AccessRoleGrantUpdate {
  allow: Boolean!

  """
  A list of controls that are allowed or denied by this grant. Each subjectType has a list of available controls, available under Query.subjectTypes.
  """
  controls: [String!]
  subjectType: String

  """
  A list of tags to restrict a grant. For instance, if this is added to a grant on PromptAnswer-update, each tag refers to a subset of App Requests.
  """
  tags: [AccessTagInput!]
}

input AccessRoleInput {
  """
  A description of the role. This is not used for anything, but can be useful for admins to understand what the role is trying to do.
  """
  description: String

  """A list of groups this role is associated with."""
  groups: [String!]!
  name: String!

  """Attach this role to a specific authentication scope, e.g. "parent"."""
  scope: String
}

type AccessRoleValidatedResponse {
  accessRole: AccessRole
  messages: [MutationMessage!]!

  """
  True if the mutation succeeded (e.g. saved data or passed validation), even if there were warnings.
  """
  success: Boolean!
}

type AccessSubjectType {
  """
  A list of all possible controls for this subjectType. Use this to populate the control dropdown when creating a grant.
  """
  controls: [AccessControl!]!

  """
  A longer explanation of the subject type for display in the role management interface.
  """
  description: String
  name: String!
  tags: [AccessTagCategory!]!

  """
  A slightly longer version of the subject type's name, for display in the role management interface.
  """
  title: String!
}

type AccessTag {
  label: String!
  value: String!
}

type AccessTagCategory {
  category: String!
  description: String
  label: String!
  listable: Boolean!

  """
  A list of all possible tags for this category. Use this to populate the tag dropdown when creating a grant.
  """
  tags: [AccessTag!]!
}

input AccessTagInput {
  """The category this tag belongs to, e.g. "State"."""
  category: String!

  """The tag value, e.g. "TX"."""
  tag: String!
}

"""A user that has or once had access to the system."""
type AccessUser {
  groups: [String!]!
  login: ID!
  otherIdentifiers: [AccessUserIdentifier!]!

  """
  A JSON object containing any information about the user that the implementing application wants to store. Could be useful for constructing personalized UI.
  """
  otherInfo: JsonData
  roles: AccessRole!
}

input AccessUserFilter {
  logins: [ID!]
  otherIdentifersByLabel: [AccessUserIdentifierInput!]
  otherIdentifiers: [String!]
  search: String
}

"""
A label and ID pair for an external user unique ID. For example, { label: "Student ID", id: "123456" }
"""
type AccessUserIdentifier {
  """The unique ID for this identifier, e.g. "123456"."""
  id: ID!

  """The label for this identifier, e.g. "Student ID"."""
  label: String!
}

"""
A label and ID pair for an external user unique ID. For example, { label: "Student ID", id: "123456" }
"""
input AccessUserIdentifierInput {
  id: ID!
  label: String!
}

"""
Represents a group of applications all being applied for at the same time. As part of the request, multiple applications will be created and either eliminated as ineligible or submitted for approval.
"""
type AppRequest {
  """Actions the user can take on this app request."""
  actions: AppRequestActions!
  applications: [Application!]!

  """
  Date that this request was considered closed and no longer editable. If active or re-opened, will be null. If closed again, will be the second closure date.
  """
  closedAt: DateTime
  createdAt: DateTime!

  """
  All data that has been gathered from the user for this request. It is a Record whose properties are the prompt keys and values are the data gathered by the corresponding prompt dialog.
  """
  data(
    """
    Provide the schemaVersion at the time the UI was built. Will throw an error if the client is too old, so it knows to refresh.
    """
    schemaVersion: String
  ): JsonData!
  id: ID!

  """
  Indexes associated with the App Request. These are pieces of data extracted from the App Request by individual prompts in the ReqQuest project. They have several uses such as filtering App Requests and enriching list views.
  """
  indexCategories(
    """
    Returns indexes that are flagged to appear in this destination. Also sorts for this destination.
    """
    for: AppRequestIndexDestination
  ): [AppRequestIndexCategory!]!

  """The period this appRequest is associated with."""
  period: Period!

  """
  Retrieve a specific prompt by its ID. This is useful for the UI to get the full prompt data and configuration when trying to edit an individual prompt. We don't want to be downloading all the config data for everything up front.
  """
  prompt(promptId: ID!): RequirementPrompt!
  status: AppRequestStatus!
  updatedAt: DateTime!
}

type AppRequestActions {
  """
  User may cancel this app request as the owner. Separate from closing as a reviewer/admin.
  """
  cancel: Boolean!

  """
  User may close this app request as a reviewer/admin. Separate from cancelling as the app request owner.
  """
  close: Boolean!

  """User may make an offer on this app request."""
  offer: Boolean!

  """
  User may reopen this app request, whether as the owner or as a reviewer/admin.
  """
  reopen: Boolean!

  """User may return this app request to the applicant phase."""
  return: Boolean!

  """Whether the user can view this app request as a reviewer."""
  review: Boolean!

  """User may submit this app request either as or on behalf of the owner."""
  submit: Boolean!
}

input AppRequestFilter {
  """
  true -> only return appRequests that are closed. false -> only return appRequests that are open. null -> return all appRequests.
  """
  closed: Boolean
  ids: [ID!]

  """Only return appRequests that are owned by one the given logins."""
  logins: [ID!]

  """Only return appRequests that are owned by the current user."""
  own: Boolean
  periodIds: [ID!]
  status: [AppRequestStatus!]
}

type AppRequestIndexCategory {
  """
  If this is > 0, the index values should be shown on the main app request list page, sorted by this priority in descending order.
  """
  appRequestListPriority: Float

  """
  If this is > 0, the index values should be shown on the applicant dashboard, sorted by this priority in descending order.
  """
  applicantDashboardPriority: Float
  category: String!
  categoryLabel: String!

  """
  If this is > 0, the index values should be shown on the list filters, sorted by this priority in descending order.
  """
  listFiltersPriority: Float

  """
  If this is > 0, the index values should be shown on the reviewer dashboard, sorted by this priority in descending order.
  """
  reviewerDashboardPriority: Float
  values: [AppRequestIndexValue!]!
}

"""This is used to indicate where the index values should be displayed."""
enum AppRequestIndexDestination {
  """
  Show these index values when listing App Requests on the applicant dashboard.
  """
  APPLICANT_DASHBOARD

  """
  Show these index values when listing App Requests in the main list page.
  """
  APP_REQUEST_LIST

  """Allow the user to filter on these index values on the main list page."""
  LIST_FILTERS

  """
  Show these index values when listing App Requests on the reviewer dashboard.
  """
  REVIEWER_DASHBOARD
}

"""
This is used to list all the available filters for the app request list.
"""
type AppRequestIndexFilter {
  category: String!
  categoryLabel: String!
  listable: Boolean!
  values(search: String): [AppRequestIndexValue!]!
}

type AppRequestIndexValue {
  label: String!
  value: String!
}

"\n    The status of an appRequest. This status is computed based on the \"dbStatus\" recorded in\n    the database and the status of each application.\n  "
enum AppRequestStatus {
  """
  Reviewer has approved an offer and we are waiting for the applicant to accept. This status is unreachable if the period has no ACCEPTANCE requirements.
  """
  ACCEPTANCE

  """
  Applicant has accepted an offer on at least one application and no applications are still pending acceptance.
  """
  ACCEPTED

  """
  Applicant has submitted and any pre-approval requirements have been met. We are waiting for a reviewer to do their part.
  """
  APPROVAL

  """
  Applicant has submitted, at least one application is in an approved state, and no applications are pending.
  """
  APPROVED

  """
  Applicant cancelled the request before submitting. The applicant may be permitted to uncancel and continue, if the period is still open.
  """
  CANCELLED

  """
  Applicant has not yet submitted but ALL applications have been disqualified. Applicant may continue editing prompts until the App Request is closed.
  """
  DISQUALIFIED
  NOT_ACCEPTED

  """
  Applicant has submitted, and ALL applications have been disqualified, no applications are pending.
  """
  NOT_APPROVED

  """
  Applicant has submitted and we are waiting for pre-approval requirements to resolve (these are automations like waiting for data to show up in an external system).
  """
  PREAPPROVAL

  """
  Applicant has completed all prompts and is ready to submit. At least one application is eligible to proceed.
  """
  READY_TO_SUBMIT

  """Applicant has begun the process and has not yet submitted."""
  STARTED

  """
  Applicant withdrew the request after submitting. The request must be re-opened (if eligible) to be edited again.
  """
  WITHDRAWN
}

"""
An application represents the applicant applying to a specific program. Each appRequest has multiple applications - one per program defined in the system. Some applications are mutually exclusive and/or will be eliminated early based on PREQUAL requirements, but they all technically exist in the data model - there is no concept of picking one application over another, just two applications where one dies and the other survives.
"""
type Application {
  actions: ApplicationActions!
  id: ID!

  """The navigation title of the program this application is for."""
  navTitle: String!
  requirements: [ApplicationRequirement!]!
  status: ApplicationStatus!

  """
  When one of the application's requirements is failing or throwing a warning, its reason will be copied here for convenience. If there is a warning and then later a failure, the failure reason will win.
  """
  statusReason: String

  """The title of the program this application is for."""
  title: String!
}

type ApplicationActions {
  viewAsReviewer: Boolean!
}

"""
The specific instance of a requirement on a particular application. Stores the status of the requirement, e.g. being satisfied or not.
"""
type ApplicationRequirement {
  application: Application!

  """
  The configuration data for this requirement in the app request's period.
  """
  configurationData: JsonData

  """
  An internal description of the requirement. Probably not shown to users.
  """
  description: String!
  id: ID!

  """
  A human and machine readable unique and stable identifier that we can use to add javascript logic to the evaluation of whether a requirement is satisfied. For example: "gi_ch33_must_be_post911"
  """
  key: String!

  """
  A human readable title for the requirement in the navigation. You probably want it to be shorter than the full title. If not provided, the title will be used.
  """
  navTitle: String!
  prompts: [RequirementPrompt!]!

  """
  When true, means that the requirement has not been made moot by an earlier requirement failing. It may still need to be hidden from navigation based on evaluatedInEarlierApplication.
  """
  reachable: Boolean!

  """
  The smart title for this requirement in the app request's period. For instance, might be "Applicant must have GPA over 3.4" instead of the regular title "Applicant must meet GPA requirement". Will fall back to the regular title for any requirement that does not provide a smart title.
  """
  smartTitle: String!

  """The status of the requirement. This is what will be shown to users."""
  status: RequirementStatus!

  """
  The reason why the requirement is in the status it is in. This will be shown to the applicant.
  """
  statusReason: String

  """
  A human readable title for the requirement. This is what will be shown to users.
  """
  title: String!

  """
  The type of requirement. This determines when the requirement is evaluated and who can see the requirement.
  """
  type: RequirementType!
}

"\n    The status of an application. This is usually a computed field, not stored in the database. The status\n    is computed based on the status of the appRequest and of the requirements for the program. If\n    the appRequest is CLOSED, the status should permanently match the ApplicationStatusDB instead of being\n    computed. If the appRequest is CANCELLED, all applications should be CANCELLED as well.\n  "
enum ApplicationStatus {
  """
  The application has been approved and an offer has been submitted for applicant acceptance. This status is only possible for programs with at least one ACCEPTANCE requirement.
  """
  ACCEPTANCE

  """
  The application's benefit has been accepted by the applicant. This status is only possible for programs with at least one ACCEPTANCE requirement.
  """
  ACCEPTED

  """
  The application has been submitted, has passed preapproval, and is awaiting approval.
  """
  APPROVAL

  """The application has been approved."""
  APPROVED

  "\n      The appRequest (and thus the application inside it) has been cancelled by the applicant. In\n      some cases, individual programs may have a requirement that the applicant agrees that they\n      desire to apply. In that case the appRequest status is not CANCELLED, and neither is the application\n      status. It will actually be FAILED_PREQUAL or FAILED_QUALIFICATION, and the statusReason of the\n      requirement will explain that the applicant did not wish to pursue the application.\n    "
  CANCELLED

  """
  The applicant is ineligible for the program according to the pre-qual requirements. The application/program should no longer be visible in the UI for this appRequest.
  """
  FAILED_PREQUAL

  """
  The applicant is ineligible for the program according to the qualification requirements. The application/program should remain visible in the UI and any applicable statusReason from the associated requirements should be displayed.
  """
  FAILED_QUALIFICATION

  """
  The application's benefit was rejected by the applicant. This status is only possible for programs with at least one ACCEPTANCE requirement.
  """
  NOT_ACCEPTED

  """The application has not been approved."""
  NOT_APPROVED

  """The application has been submitted and is awaiting preapproval."""
  PREAPPROVAL

  """
  The appRequest has not finished pre-qualification yet. This application does not quite exist yet and probably should not appear in the UI.
  """
  PREQUAL

  """
  The application has been pre-qualified and is awaiting further input from the applicant.
  """
  QUALIFICATION

  """
  All requirements have been evaluated as MET or NOT_APPLICABLE. The application is ready to be submitted.
  """
  READY_TO_SUBMIT

  """
  The appRequest (and thus the application inside it) was withdrawn after being submitted. If it is re-opened, it will re-open in submitted state.
  """
  WITHDRAWN
}

type Configuration {
  actions: ConfigurationAccess!
  data: JsonData!

  """The key being configured. Could be a requirement or prompt key."""
  key: String!
}

type ConfigurationAccess {
  update: Boolean!
  view: Boolean!
}

input ConfigurationFilters {
  """Return specific configurations."""
  ids: [ID!]

  """Return configurations for these keys."""
  keys: [String!]

  """Return configurations for these period codes."""
  periodCodes: [String!]

  """Return configurations for these period IDs."""
  periodIds: [ID!]
}

"""
Date and Time in ISO 8601 string format. JSON parser should convert to javascript Date type.
"""
scalar DateTime

"""Unstructured JSON data."""
scalar JsonData

type Mutation {
  """Make an offer on the app request."""
  offerAppRequest(appRequestId: ID!): ValidatedAppRequestResponse!
  roleAddGrant(grant: AccessRoleGrantCreate!, roleId: ID!, validateOnly: Boolean): AccessRoleValidatedResponse!
  roleCreate(role: AccessRoleInput!, validateOnly: Boolean): AccessRoleValidatedResponse!
  roleDelete(roleId: ID!): ValidatedResponse!
  roleDeleteGrant(grantId: ID!): AccessRoleValidatedResponse!
  roleUpdate(role: AccessRoleInput!, roleId: ID!, validateOnly: Boolean): AccessRoleValidatedResponse!
  roleUpdateGrant(grant: AccessRoleGrantUpdate!, grantId: ID!, validateOnly: Boolean): AccessRoleValidatedResponse!

  """Submit the app request."""
  submitAppRequest(appRequestId: ID!): ValidatedAppRequestResponse!
  updateConfiguration(data: JsonData!, key: String!, periodId: String!, validateOnly: Boolean): ValidatedConfigurationResponse!
  updatePeriod(id: String!, update: PeriodUpdate!, validateOnly: Boolean): ValidatedPeriodResponse!

  """Update the data for a prompt in this app request."""
  updatePrompt(data: JsonData!, promptId: ID!, validateOnly: Boolean): ValidatedAppRequestResponse!
}

type MutationMessage {
  """
  The path to the arg that produced the error. Dot-separated (lodash.get compatible) if it is deep inside an input type. Null if no particular arg can be blamed for the error.
  """
  arg: String

  """
  An error message to be shown to the end user, with the context of the given arg.
  """
  message: String!

  """The type of error message. See the enum descriptions for more detail."""
  type: MutationMessageType!
}

enum MutationMessageType {
  """This error means the mutation cannot and/or did not take place."""
  error

  """
  This message should be shown to the end user before submission to let them know ahead of time that one of their entries passed validation (e.g. username available or password strength high).
  """
  success

  """
  The mutation can and/or did complete, but the user should receive the warning anyway (e.g. "Your password sucks but I'll allow it.").
  """
  warning
}

type Period {
  actions: PeriodActions!

  """
  This is useful for filtering out periods that are no longer useful. For instance, a window might close applications after 2 weeks but the reviewers could be working.
  """
  archiveDate: DateTime

  """
  Date that this period closes for applications. Some periods do not set a close date.
  """
  closeDate: DateTime

  """
  Unique identifier for this period that references an external system. Ideally human readable.
  """
  code: String
  configurations(filter: ConfigurationFilters): [Configuration!]!
  id: ID!

  """
  Name for this period. Will be displayed to applicants if they create an App Request while two periods are simultaneously open.
  """
  name: String!

  """Date that this period opens for applications."""
  openDate: DateTime!
  programs: [PeriodProgram!]!
  prompts: [PeriodPrompt!]!
  requirements: [PeriodProgramRequirement!]!
}

type PeriodActions {
  update: Boolean!
  view: Boolean!
}

input PeriodFilters {
  """Return periods that will be archived after this date."""
  archiveAfter: DateTime

  """Return periods that were archived before this date."""
  archiveBefore: DateTime

  """Return periods that are open at this date or will be open after it."""
  closesAfter: DateTime

  """
  Return periods that closed before this date, not including that date's active period(s).
  """
  closesBefore: DateTime

  """Return periods that have any of these codes."""
  codes: [String!]

  """Return periods that have any of these IDs."""
  ids: [ID!]

  """true -> open periods. false -> closed periods. null -> all periods."""
  openNow: Boolean

  """
  Return periods that open after this date, not including that date's active period(s).
  """
  opensAfter: DateTime

  """Return periods that are open at this date or have been open before it."""
  opensBefore: DateTime
}

type PeriodProgram {
  actions: PeriodProgramActions!

  """
  Whether the program is enabled in this period. This is set by the system administrator.
  """
  enabled: Boolean!
  group: PeriodProgramActions!
  key: ID!
  navTitle: String!
  period: Period!
  requirements: [PeriodProgramRequirement!]!
  title: String!
}

type PeriodProgramActions {
  configure: Boolean!
}

type PeriodProgramRequirement {
  """The configuration for this requirement in the period."""
  configuration: Configuration!

  """
  An internal description of the requirement. Probably not shown to users.
  """
  description: String!

  """
  Whether the requirement is enabled in this period. This is set by the system administrator.
  """
  enabled: Boolean!

  """
  A human and machine readable unique and stable identifier that we can use to add javascript logic to the evaluation of whether a requirement is satisfied. For example: "gi_ch33_must_be_post911"
  """
  key: String!

  """
  A human readable title for the requirement in the navigation. You probably want it to be shorter than the full title. If not provided, the title will be used.
  """
  navTitle: String!
  prompts: [PeriodPrompt!]!

  """
  A human readable title for the requirement. This is what will be shown to users.
  """
  title: String!

  """
  The type of requirement. This determines when the requirement is evaluated and who can see the requirement.
  """
  type: RequirementType!
}

type PeriodPrompt {
  """The configuration for this prompt in the given period."""
  configuration: Configuration!

  """
  A brief description of the prompt. This should be shown to administrators to help explain the full meaning of the prompt while assigning permissions or editing its configuration.
  """
  description: String

  """
  A human and machine readable identifier for the prompt. Will be used to match prompt data with UI and API code that handles it.
  """
  key: String!

  """
  A human readable title for the prompt in the navigation. You probably want it to be shorter than the full title. If not provided, the title will be used.
  """
  navTitle: String!
  periodId: String!

  """
  A human readable title for the prompt. This is what will be shown to users.
  """
  title: String!
}

input PeriodUpdate {
  archiveDate: DateTime
  closeDate: DateTime
  code: String
  name: String!
  openDate: DateTime!
}

type Program {
  key: ID!
  navTitle: String!
  title: String!
}

input ProgramFilters {
  keys: [String!]
}

type ProgramGroup {
  key: ID!

  """
  A human readable title for the program group in the navigation. You may want it to be shorter than the full title. If not provided, the title will be used.
  """
  navTitle: String!
  programs(filter: ProgramFilters): [Program!]!

  """
  A human readable title for the program group. This will be shown to users.
  """
  title: String!
}

input ProgramGroupFilter {
  keys: [ID!]
}

"""
The visibility of a prompt on a request. This is used to determine whether the prompt should be shown to the user in the UI.
"""
enum PromptVisibility {
  """
  This RequirementPrompt is a duplicate of a RequirementPrompt that already appears earlier in the same application (it could also be duplicated yet again in an earlier application). It should not be shown to applicants. The reviewer UI may or may not want to show these repeated dependencies.
  """
  APPLICATION_DUPE

  """
  The prompt is intended to be filled in by an automation, but is otherwise available to be answered. It may or may not be visible in various UIs but it is not editable in any of them.
  """
  AUTOMATION

  """
  This RequirementPrompt is available to be answered. It is the first appearance of this prompt in the App Request. It should be visible in both the applicant and reviewer UI.
  """
  AVAILABLE

  """
  This RequirementPrompt is a duplicate of a RequirementPrompt that already appears earlier in the same app request, but it is the first appearance in its application. It should not be shown to applicants. The reviewer UI may or may not want to show these repeated dependencies.
  """
  REQUEST_DUPE

  """
  This RequirementPrompt cannot be reached, there is a requirement or prompt in front of it that could or already has disqualified the application.
  """
  UNREACHABLE
}

type Query {
  "\n    This is the global access object. Each field represents a global permission\n    like the ability to view the role management interface.\n  "
  access: Access!
  accessUsers(filter: AccessUserFilter): [AccessUser!]!
  appRequestFilters: [AppRequestIndexFilter!]!
  appRequests(filter: AppRequestFilter): [AppRequest!]!
  periods(filter: PeriodFilters): [Period!]!
  programGroups(filter: ProgramGroupFilter): [ProgramGroup!]!
  programs(filter: ProgramFilters): [Program!]!
  roles(filter: AccessRoleFilter): [AccessRole!]!

  """
  A list of all possible scopes. Scopes are used to limit users when they are accessing the system through an alternate UI or login method. For instance, if you generate an authentication token to give to a third party, it may have a scope identifying that third party and limiting their access even though they are acting as you. Roles must match the token scope in order to apply permissions.
  """
  scopes: [String!]!

  """
  This is where you get information about the authorization system. Each grant will be associated with one of these subjectTypes and optionally a list of subject instances. The grant will also have a set of controls, and each control will have an optional set of tags. The tags are used to limit the scope of the grant.
  """
  subjectTypes: [AccessSubjectType!]!
}

"""
A RequestPrompt is an instance of a Prompt on a particular request. Once the user has answered the prompt, it contains the answer and the prompt status on that request.
"""
type RequirementPrompt {
  """Whether the prompt has been answered on this request."""
  answered: Boolean!

  """The configuration data for this prompt in the app request's period."""
  configurationData: JsonData!

  """
  All the configuration data that could be relevant for this prompt. This includes its own config, and also the config data for any requirements and programs that are related to it.
  """
  configurationRelatedData: JsonData!

  """
  The data that has been gathered from the user in response to this prompt. The schema is controlled by the question's implementation.
  """
  data(
    """
    Provide the schemaVersion at the time the UI was built. Will throw an error if the client is too old, so it knows to refresh.
    """
    schemaVersion: String
  ): JsonData

  """
  A brief description of the prompt. This should be shown to administrators to help explain the full meaning of the prompt while assigning permissions or editing its configuration.
  """
  description: String

  """
  Any data that the API needs to provide to the UI to display the prompt properly. For instance, if the prompt text is in the database and able to be modified by admins, the UI can't hardcode the prompt text and needs it from the API. Could also be used to pull reference information from an external system, e.g. a student's course schedule, for display in the prompt dialog.
  """
  fetchedData(
    """
    Provide the schemaVersion at the time the UI was built. Will throw an error if the client is too old, so it knows to refresh.
    """
    schemaVersion: String
  ): JsonData
  id: ID!

  """
  When true, this prompt has been invalidated by the answer to another prompt. The `answered` field should remain false until the user specifically answers this prompt again, regardless of the output of the definition's `complete` method.
  """
  invalidated: Boolean!

  """
  A human and machine readable identifier for the prompt. Will be used to match prompt data with UI and API code that handles it.
  """
  key: String!

  """
  A human readable title for the prompt in the navigation. You probably want it to be shorter than the full title. If not provided, the title will be used.
  """
  navTitle: String!

  """
  Preload data that has been generated according to the prompt definition. For example, a prompt might query the database for answers given in previous requests or query an external API to learn facts about the user.
  """
  preloadData(
    """
    Provide the schemaVersion at the time the UI was built. Will throw an error if the client is too old, so it knows to refresh.
    """
    schemaVersion: String
  ): JsonData

  """
  A human readable title for the prompt. This is what will be shown to users.
  """
  title: String!

  """
  The visibility of the prompt on the request. This is used to determine whether the prompt should be shown to the user in the UI.
  """
  visibility: PromptVisibility!
}

enum RequirementStatus {
  """
  The requirement has not been met, and it means the application is denied/ineligible.
  """
  DISQUALIFYING

  """The requirement has been met."""
  MET

  """
  The requirement is not applicable. The application should not yet be denied, proceed to the next requirement.
  """
  NOT_APPLICABLE

  """
  The requirement cannot be evaluated yet because one or more questions are unanswered.
  """
  PENDING

  """
  The requirement has not been met, but the application may still be approved. The requirement should be marked in some way as not quite satisfactory. The statusReason may explain further what is wrong.
  """
  WARNING
}

enum RequirementType {
  """
  A requirement that should only be shown to applicants after the application has been through review and an offer has been made. The applicant can come back and fill out the requirement's prompts to accept the offer.
  """
  ACCEPTANCE

  """
  A requirement that should only be shown to agents/reviewers and must have a non-pending status before an application is closed.
  """
  APPROVAL

  """
  A requirement that should be shown to applicants at the end of the request process, prior to review and submission, outside the context of the individual programs. It is intended for acknowledgements like "I affirm that I have given truthful answers". It wouldn't make sense to have them affirm that their answers are truthful in one application but not in the others.
  """
  POSTQUAL

  """
  A requirement that has no prompts and must have a non-PENDING status before an application may be reviewed. Use this for materials/data that must appear in an external system before a reviewer will be able to begin their work.
  """
  PREAPPROVAL

  """
  A requirement that should have a non-PENDING status before the user is shown their programs. Only the applications for programs whose PREQUAL requirements are MET or NOT_APPLICABLE should be visible. The others should be entirely hidden, rather than being shown in a disabled/ineligible state.
  """
  PREQUAL

  """
  A requirement that should have a non-pending status before an application may be submitted for review. Programs with a DISQUALIFYING requirement of type APPLICATION should be visible to the submitter but visually distinct as disabled/ineligible.
  """
  QUALIFICATION
}

type RoleActions {
  delete: Boolean!
  update: Boolean!
}

type ValidatedAppRequestResponse {
  appRequest: AppRequest!
  messages: [MutationMessage!]!

  """
  True if the mutation succeeded (e.g. saved data or passed validation), even if there were warnings.
  """
  success: Boolean!
}

type ValidatedConfigurationResponse {
  configuration: Configuration
  messages: [MutationMessage!]!

  """
  True if the mutation succeeded (e.g. saved data or passed validation), even if there were warnings.
  """
  success: Boolean!
}

type ValidatedPeriodResponse {
  messages: [MutationMessage!]!
  period: Period

  """
  True if the mutation succeeded (e.g. saved data or passed validation), even if there were warnings.
  """
  success: Boolean!
}

type ValidatedResponse {
  messages: [MutationMessage!]!

  """
  True if the mutation succeeded (e.g. saved data or passed validation), even if there were warnings.
  """
  success: Boolean!
}